// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: stewdy.proto

/*
	Package stewdy is a generated protocol buffer package.

	It is generated from these files:
		stewdy.proto

	It has these top-level messages:
		Campaign
		Schedule
		Target
*/
package stewdy

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Campaign struct {
	Id                 string      `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	QueueID            string      `protobuf:"bytes,2,opt,name=queueID,proto3" json:"queueID,omitempty"`
	IsActive           bool        `protobuf:"varint,3,opt,name=isActive,proto3" json:"isActive,omitempty"`
	ResetOnNewSchedule bool        `protobuf:"varint,4,opt,name=resetOnNewSchedule,proto3" json:"resetOnNewSchedule,omitempty"`
	ResetOnActivation  bool        `protobuf:"varint,5,opt,name=resetOnActivation,proto3" json:"resetOnActivation,omitempty"`
	MaxAttempts        int32       `protobuf:"varint,6,opt,name=maxAttempts,proto3" json:"maxAttempts,omitempty"`
	NextAttemptDelay   int64       `protobuf:"varint,7,opt,name=nextAttemptDelay,proto3" json:"nextAttemptDelay,omitempty"`
	ConcurrentCalls    int32       `protobuf:"varint,8,opt,name=concurrentCalls,proto3" json:"concurrentCalls,omitempty"`
	Multiplier         int32       `protobuf:"varint,9,opt,name=multiplier,proto3" json:"multiplier,omitempty"`
	BatchSize          int32       `protobuf:"varint,10,opt,name=batchSize,proto3" json:"batchSize,omitempty"`
	TimeTable          []*Schedule `protobuf:"bytes,14,rep,name=timeTable" json:"timeTable,omitempty"`
	CurrentScheduleID  string      `protobuf:"bytes,15,opt,name=currentScheduleID,proto3" json:"currentScheduleID,omitempty"`
}

func (m *Campaign) Reset()                    { *m = Campaign{} }
func (m *Campaign) String() string            { return proto.CompactTextString(m) }
func (*Campaign) ProtoMessage()               {}
func (*Campaign) Descriptor() ([]byte, []int) { return fileDescriptorStewdy, []int{0} }

func (m *Campaign) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Campaign) GetQueueID() string {
	if m != nil {
		return m.QueueID
	}
	return ""
}

func (m *Campaign) GetIsActive() bool {
	if m != nil {
		return m.IsActive
	}
	return false
}

func (m *Campaign) GetResetOnNewSchedule() bool {
	if m != nil {
		return m.ResetOnNewSchedule
	}
	return false
}

func (m *Campaign) GetResetOnActivation() bool {
	if m != nil {
		return m.ResetOnActivation
	}
	return false
}

func (m *Campaign) GetMaxAttempts() int32 {
	if m != nil {
		return m.MaxAttempts
	}
	return 0
}

func (m *Campaign) GetNextAttemptDelay() int64 {
	if m != nil {
		return m.NextAttemptDelay
	}
	return 0
}

func (m *Campaign) GetConcurrentCalls() int32 {
	if m != nil {
		return m.ConcurrentCalls
	}
	return 0
}

func (m *Campaign) GetMultiplier() int32 {
	if m != nil {
		return m.Multiplier
	}
	return 0
}

func (m *Campaign) GetBatchSize() int32 {
	if m != nil {
		return m.BatchSize
	}
	return 0
}

func (m *Campaign) GetTimeTable() []*Schedule {
	if m != nil {
		return m.TimeTable
	}
	return nil
}

func (m *Campaign) GetCurrentScheduleID() string {
	if m != nil {
		return m.CurrentScheduleID
	}
	return ""
}

type Schedule struct {
	Id      string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Weekday int32  `protobuf:"varint,2,opt,name=weekday,proto3" json:"weekday,omitempty"`
	Start   int32  `protobuf:"varint,3,opt,name=start,proto3" json:"start,omitempty"`
	Stop    int32  `protobuf:"varint,4,opt,name=stop,proto3" json:"stop,omitempty"`
}

func (m *Schedule) Reset()                    { *m = Schedule{} }
func (m *Schedule) String() string            { return proto.CompactTextString(m) }
func (*Schedule) ProtoMessage()               {}
func (*Schedule) Descriptor() ([]byte, []int) { return fileDescriptorStewdy, []int{1} }

func (m *Schedule) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Schedule) GetWeekday() int32 {
	if m != nil {
		return m.Weekday
	}
	return 0
}

func (m *Schedule) GetStart() int32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *Schedule) GetStop() int32 {
	if m != nil {
		return m.Stop
	}
	return 0
}

type Target struct {
	Id                  string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	CampaignID          string `protobuf:"bytes,2,opt,name=campaignID,proto3" json:"campaignID,omitempty"`
	PhoneNumber         string `protobuf:"bytes,3,opt,name=phoneNumber,proto3" json:"phoneNumber,omitempty"`
	ClientId            string `protobuf:"bytes,4,opt,name=clientId,proto3" json:"clientId,omitempty"`
	PreferredOperatorID string `protobuf:"bytes,5,opt,name=preferredOperatorID,proto3" json:"preferredOperatorID,omitempty"`
	Attempts            int32  `protobuf:"varint,6,opt,name=attempts,proto3" json:"attempts,omitempty"`
	LastAttemptTime     int64  `protobuf:"varint,7,opt,name=lastAttemptTime,proto3" json:"lastAttemptTime,omitempty"`
	NextAttemptTime     int64  `protobuf:"varint,8,opt,name=nextAttemptTime,proto3" json:"nextAttemptTime,omitempty"`
	UniqueId            string `protobuf:"bytes,9,opt,name=uniqueId,proto3" json:"uniqueId,omitempty"`
}

func (m *Target) Reset()                    { *m = Target{} }
func (m *Target) String() string            { return proto.CompactTextString(m) }
func (*Target) ProtoMessage()               {}
func (*Target) Descriptor() ([]byte, []int) { return fileDescriptorStewdy, []int{2} }

func (m *Target) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Target) GetCampaignID() string {
	if m != nil {
		return m.CampaignID
	}
	return ""
}

func (m *Target) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

func (m *Target) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *Target) GetPreferredOperatorID() string {
	if m != nil {
		return m.PreferredOperatorID
	}
	return ""
}

func (m *Target) GetAttempts() int32 {
	if m != nil {
		return m.Attempts
	}
	return 0
}

func (m *Target) GetLastAttemptTime() int64 {
	if m != nil {
		return m.LastAttemptTime
	}
	return 0
}

func (m *Target) GetNextAttemptTime() int64 {
	if m != nil {
		return m.NextAttemptTime
	}
	return 0
}

func (m *Target) GetUniqueId() string {
	if m != nil {
		return m.UniqueId
	}
	return ""
}

func init() {
	proto.RegisterType((*Campaign)(nil), "stewdy.campaign")
	proto.RegisterType((*Schedule)(nil), "stewdy.schedule")
	proto.RegisterType((*Target)(nil), "stewdy.target")
}
func (m *Campaign) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Campaign) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStewdy(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.QueueID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStewdy(dAtA, i, uint64(len(m.QueueID)))
		i += copy(dAtA[i:], m.QueueID)
	}
	if m.IsActive {
		dAtA[i] = 0x18
		i++
		if m.IsActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ResetOnNewSchedule {
		dAtA[i] = 0x20
		i++
		if m.ResetOnNewSchedule {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ResetOnActivation {
		dAtA[i] = 0x28
		i++
		if m.ResetOnActivation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MaxAttempts != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintStewdy(dAtA, i, uint64(m.MaxAttempts))
	}
	if m.NextAttemptDelay != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintStewdy(dAtA, i, uint64(m.NextAttemptDelay))
	}
	if m.ConcurrentCalls != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintStewdy(dAtA, i, uint64(m.ConcurrentCalls))
	}
	if m.Multiplier != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintStewdy(dAtA, i, uint64(m.Multiplier))
	}
	if m.BatchSize != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintStewdy(dAtA, i, uint64(m.BatchSize))
	}
	if len(m.TimeTable) > 0 {
		for _, msg := range m.TimeTable {
			dAtA[i] = 0x72
			i++
			i = encodeVarintStewdy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.CurrentScheduleID) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintStewdy(dAtA, i, uint64(len(m.CurrentScheduleID)))
		i += copy(dAtA[i:], m.CurrentScheduleID)
	}
	return i, nil
}

func (m *Schedule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Schedule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStewdy(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.Weekday != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStewdy(dAtA, i, uint64(m.Weekday))
	}
	if m.Start != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStewdy(dAtA, i, uint64(m.Start))
	}
	if m.Stop != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStewdy(dAtA, i, uint64(m.Stop))
	}
	return i, nil
}

func (m *Target) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Target) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStewdy(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.CampaignID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStewdy(dAtA, i, uint64(len(m.CampaignID)))
		i += copy(dAtA[i:], m.CampaignID)
	}
	if len(m.PhoneNumber) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStewdy(dAtA, i, uint64(len(m.PhoneNumber)))
		i += copy(dAtA[i:], m.PhoneNumber)
	}
	if len(m.ClientId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStewdy(dAtA, i, uint64(len(m.ClientId)))
		i += copy(dAtA[i:], m.ClientId)
	}
	if len(m.PreferredOperatorID) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStewdy(dAtA, i, uint64(len(m.PreferredOperatorID)))
		i += copy(dAtA[i:], m.PreferredOperatorID)
	}
	if m.Attempts != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintStewdy(dAtA, i, uint64(m.Attempts))
	}
	if m.LastAttemptTime != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintStewdy(dAtA, i, uint64(m.LastAttemptTime))
	}
	if m.NextAttemptTime != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintStewdy(dAtA, i, uint64(m.NextAttemptTime))
	}
	if len(m.UniqueId) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintStewdy(dAtA, i, uint64(len(m.UniqueId)))
		i += copy(dAtA[i:], m.UniqueId)
	}
	return i, nil
}

func encodeVarintStewdy(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Campaign) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovStewdy(uint64(l))
	}
	l = len(m.QueueID)
	if l > 0 {
		n += 1 + l + sovStewdy(uint64(l))
	}
	if m.IsActive {
		n += 2
	}
	if m.ResetOnNewSchedule {
		n += 2
	}
	if m.ResetOnActivation {
		n += 2
	}
	if m.MaxAttempts != 0 {
		n += 1 + sovStewdy(uint64(m.MaxAttempts))
	}
	if m.NextAttemptDelay != 0 {
		n += 1 + sovStewdy(uint64(m.NextAttemptDelay))
	}
	if m.ConcurrentCalls != 0 {
		n += 1 + sovStewdy(uint64(m.ConcurrentCalls))
	}
	if m.Multiplier != 0 {
		n += 1 + sovStewdy(uint64(m.Multiplier))
	}
	if m.BatchSize != 0 {
		n += 1 + sovStewdy(uint64(m.BatchSize))
	}
	if len(m.TimeTable) > 0 {
		for _, e := range m.TimeTable {
			l = e.Size()
			n += 1 + l + sovStewdy(uint64(l))
		}
	}
	l = len(m.CurrentScheduleID)
	if l > 0 {
		n += 1 + l + sovStewdy(uint64(l))
	}
	return n
}

func (m *Schedule) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovStewdy(uint64(l))
	}
	if m.Weekday != 0 {
		n += 1 + sovStewdy(uint64(m.Weekday))
	}
	if m.Start != 0 {
		n += 1 + sovStewdy(uint64(m.Start))
	}
	if m.Stop != 0 {
		n += 1 + sovStewdy(uint64(m.Stop))
	}
	return n
}

func (m *Target) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovStewdy(uint64(l))
	}
	l = len(m.CampaignID)
	if l > 0 {
		n += 1 + l + sovStewdy(uint64(l))
	}
	l = len(m.PhoneNumber)
	if l > 0 {
		n += 1 + l + sovStewdy(uint64(l))
	}
	l = len(m.ClientId)
	if l > 0 {
		n += 1 + l + sovStewdy(uint64(l))
	}
	l = len(m.PreferredOperatorID)
	if l > 0 {
		n += 1 + l + sovStewdy(uint64(l))
	}
	if m.Attempts != 0 {
		n += 1 + sovStewdy(uint64(m.Attempts))
	}
	if m.LastAttemptTime != 0 {
		n += 1 + sovStewdy(uint64(m.LastAttemptTime))
	}
	if m.NextAttemptTime != 0 {
		n += 1 + sovStewdy(uint64(m.NextAttemptTime))
	}
	l = len(m.UniqueId)
	if l > 0 {
		n += 1 + l + sovStewdy(uint64(l))
	}
	return n
}

func sovStewdy(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozStewdy(x uint64) (n int) {
	return sovStewdy(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Campaign) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStewdy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: campaign: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: campaign: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStewdy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStewdy
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStewdy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStewdy
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueueID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStewdy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsActive = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResetOnNewSchedule", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStewdy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ResetOnNewSchedule = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResetOnActivation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStewdy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ResetOnActivation = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAttempts", wireType)
			}
			m.MaxAttempts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStewdy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxAttempts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextAttemptDelay", wireType)
			}
			m.NextAttemptDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStewdy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextAttemptDelay |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConcurrentCalls", wireType)
			}
			m.ConcurrentCalls = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStewdy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConcurrentCalls |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Multiplier", wireType)
			}
			m.Multiplier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStewdy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Multiplier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchSize", wireType)
			}
			m.BatchSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStewdy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStewdy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStewdy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimeTable = append(m.TimeTable, &Schedule{})
			if err := m.TimeTable[len(m.TimeTable)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentScheduleID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStewdy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStewdy
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrentScheduleID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStewdy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStewdy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Schedule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStewdy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: schedule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: schedule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStewdy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStewdy
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weekday", wireType)
			}
			m.Weekday = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStewdy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weekday |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStewdy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stop", wireType)
			}
			m.Stop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStewdy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stop |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStewdy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStewdy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Target) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStewdy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: target: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: target: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStewdy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStewdy
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CampaignID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStewdy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStewdy
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CampaignID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStewdy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStewdy
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStewdy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStewdy
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreferredOperatorID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStewdy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStewdy
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreferredOperatorID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attempts", wireType)
			}
			m.Attempts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStewdy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Attempts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastAttemptTime", wireType)
			}
			m.LastAttemptTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStewdy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastAttemptTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextAttemptTime", wireType)
			}
			m.NextAttemptTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStewdy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextAttemptTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStewdy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStewdy
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStewdy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStewdy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStewdy(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStewdy
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStewdy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStewdy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthStewdy
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowStewdy
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipStewdy(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthStewdy = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStewdy   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("stewdy.proto", fileDescriptorStewdy) }

var fileDescriptorStewdy = []byte{
	// 476 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x93, 0x4f, 0x6e, 0xd3, 0x40,
	0x14, 0xc6, 0x71, 0x52, 0xa7, 0xf6, 0x2b, 0x6a, 0xc3, 0xc0, 0x62, 0x84, 0x90, 0x65, 0x65, 0x65,
	0x21, 0x14, 0x21, 0x38, 0x41, 0x21, 0x1b, 0x6f, 0x5a, 0x69, 0xda, 0x35, 0xd2, 0xc4, 0x7e, 0x34,
	0x23, 0xfc, 0xaf, 0x33, 0xcf, 0xa4, 0xe1, 0x24, 0x1c, 0x84, 0x13, 0xb0, 0x62, 0xc9, 0x11, 0x50,
	0xb8, 0x08, 0xf2, 0xc4, 0x76, 0x4d, 0x92, 0x9d, 0xbf, 0xdf, 0xfb, 0xf4, 0x9e, 0x34, 0xdf, 0x67,
	0x78, 0x6a, 0x08, 0xd7, 0xe9, 0x66, 0x5e, 0xe9, 0x92, 0x4a, 0x36, 0xd9, 0xa9, 0xd9, 0xcf, 0x31,
	0x78, 0x89, 0xcc, 0x2b, 0xa9, 0xee, 0x0a, 0x76, 0x0e, 0x23, 0x95, 0x72, 0x27, 0x74, 0x22, 0x5f,
	0x8c, 0x54, 0xca, 0x38, 0x9c, 0xde, 0xd7, 0x58, 0x63, 0xbc, 0xe0, 0x23, 0x0b, 0x3b, 0xc9, 0x5e,
	0x82, 0xa7, 0xcc, 0x65, 0x42, 0xea, 0x2b, 0xf2, 0x71, 0xe8, 0x44, 0x9e, 0xe8, 0x35, 0x9b, 0x03,
	0xd3, 0x68, 0x90, 0xae, 0x8b, 0x2b, 0x5c, 0xdf, 0x24, 0x2b, 0x4c, 0xeb, 0x0c, 0xf9, 0x89, 0x75,
	0x1d, 0x99, 0xb0, 0x37, 0xf0, 0xac, 0xa5, 0x76, 0x81, 0x24, 0x55, 0x16, 0xdc, 0xb5, 0xf6, 0xc3,
	0x01, 0x0b, 0xe1, 0x2c, 0x97, 0x0f, 0x97, 0x44, 0x98, 0x57, 0x64, 0xf8, 0x24, 0x74, 0x22, 0x57,
	0x0c, 0x11, 0x7b, 0x0d, 0xd3, 0x02, 0x1f, 0xa8, 0xd5, 0x0b, 0xcc, 0xe4, 0x86, 0x9f, 0x86, 0x4e,
	0x34, 0x16, 0x07, 0x9c, 0x45, 0x70, 0x91, 0x94, 0x45, 0x52, 0x6b, 0x8d, 0x05, 0x7d, 0x94, 0x59,
	0x66, 0xb8, 0x67, 0x37, 0xee, 0x63, 0x16, 0x00, 0xe4, 0x75, 0x46, 0xaa, 0xca, 0x14, 0x6a, 0xee,
	0x5b, 0xd3, 0x80, 0xb0, 0x57, 0xe0, 0x2f, 0x25, 0x25, 0xab, 0x1b, 0xf5, 0x0d, 0x39, 0xd8, 0xf1,
	0x23, 0x60, 0x73, 0xf0, 0x49, 0xe5, 0x78, 0x2b, 0x97, 0x19, 0xf2, 0xf3, 0x70, 0x1c, 0x9d, 0xbd,
	0x9b, 0xce, 0xdb, 0x40, 0x4c, 0xfb, 0x10, 0xe2, 0xd1, 0xd2, 0xbc, 0x49, 0x7b, 0xbd, 0x7b, 0xa6,
	0x78, 0xc1, 0x2f, 0x6c, 0x06, 0x87, 0x83, 0xd9, 0x27, 0xf0, 0xba, 0x25, 0xc7, 0x32, 0x5c, 0x23,
	0x7e, 0x49, 0xe5, 0xc6, 0x66, 0xe8, 0x8a, 0x4e, 0xb2, 0x17, 0xe0, 0x1a, 0x92, 0x9a, 0x6c, 0x80,
	0xae, 0xd8, 0x09, 0xc6, 0xe0, 0xc4, 0x50, 0x59, 0xd9, 0xbc, 0x5c, 0x61, 0xbf, 0x67, 0x3f, 0x46,
	0x30, 0x21, 0xa9, 0xef, 0x90, 0x0e, 0xd6, 0x07, 0x00, 0x5d, 0x7d, 0xfa, 0x96, 0x0c, 0x48, 0x13,
	0x57, 0xb5, 0x2a, 0x0b, 0xbc, 0xaa, 0xf3, 0x25, 0x6a, 0x7b, 0xca, 0x17, 0x43, 0xd4, 0x54, 0x29,
	0xc9, 0x14, 0x16, 0x14, 0xa7, 0xf6, 0xa8, 0x2f, 0x7a, 0xcd, 0xde, 0xc2, 0xf3, 0x4a, 0xe3, 0x67,
	0xd4, 0x1a, 0xd3, 0xeb, 0x0a, 0xb5, 0xa4, 0x52, 0xc7, 0x0b, 0x5b, 0x0e, 0x5f, 0x1c, 0x1b, 0x35,
	0xdb, 0xe4, 0xff, 0xdd, 0xe8, 0x75, 0x13, 0x76, 0x26, 0x4d, 0x57, 0x80, 0x5b, 0x95, 0x63, 0xdb,
	0x8b, 0x7d, 0xdc, 0x38, 0x07, 0x55, 0xb1, 0x4e, 0x6f, 0xe7, 0xdc, 0xc3, 0xcd, 0xbd, 0xba, 0x50,
	0xf7, 0x35, 0xc6, 0xa9, 0x2d, 0x85, 0x2f, 0x7a, 0xfd, 0x61, 0xfa, 0x6b, 0x1b, 0x38, 0xbf, 0xb7,
	0x81, 0xf3, 0x67, 0x1b, 0x38, 0xdf, 0xff, 0x06, 0x4f, 0x96, 0x13, 0xfb, 0xf3, 0xbd, 0xff, 0x17,
	0x00, 0x00, 0xff, 0xff, 0x0c, 0xe3, 0x34, 0x5a, 0x8c, 0x03, 0x00, 0x00,
}
